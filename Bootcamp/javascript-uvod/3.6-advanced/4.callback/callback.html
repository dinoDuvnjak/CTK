<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        //pokazi u konzoli
        // ovo je callback funkcija
        // funkcija koja se poziva kada se dogodi neki dogaÄ‘aj
        // to poziva sam objekat, a ne mi
        document.addEventListener("keydown", function(e) {
            //console.log(e);
            //console.log("Pritisnuta tipka:", e.key);
        });

        //primjer custom event listenera
        function customEventListener(type, callback) {

            const event = { 
                type: "keypress",
                key: "Enter", 
                message: "Custom event triggered!" 
            };

            if (type === event.type) {
                callback(event);
            }
        }

        customEventListener("keypress", function(event) {
            console.log(event);
        });


        //primjer mrezne simulacije
        function dohvatiPodatke(url, callback) {
            // simuliramo mreÅ¾no kaÅ¡njenje
            //napisi settimeout ali bez arrow funkcije
            setTimeout(function (params) {
                const data = { id: 1, name: 'Pero' }; 
                callback(null, data);
            }, 1500)
        }

        // error-first callback: prvo error, pa rezultat
        dohvatiPodatke('https://api.example.com/user', (err, korisnik) => {
        if (err) {
            console.error('GreÅ¡ka pri dohvaÄ‡anju:', err);
            return;
        }
        console.log('Korisnik:', korisnik);
        });


        //primjer iz svijet
        // fetch("https://api.example.com/podaci")
        // .then(response => response.json())
        // .then(data => console.log(data))
        // .catch(error => console.error("GreÅ¡ka:", error));
        //then je callback funkcija koja se izvrÅ¡ava kada se podaci uspjeÅ¡no dobiju
        //catch je callback funkcija koja se izvrÅ¡ava kada doÄ‘e do greÅ¡ke

        // ğŸ¯ Definiramo novi Promise
        const fetchData = new Promise((resolve, reject) => {
            let dataReceived = true;

            // Simulacija kaÅ¡njenja od 2 sekunde
            setTimeout(() => {
                if (dataReceived) {
                    resolve("Data fetched successfully!");
                } else {
                    reject("Failed to fetch data.");
                }
            }, 2000);
        });

        // âœ… Koristimo .then() i .catch() da uhvatimo rezultat
        fetchData
        .then((message) => {
            console.log(message); // Ispis: "Data fetched successfully!"
        })
        .catch((error) => {
            console.error(error); // U sluÄaju greÅ¡ke
        });

        // ğŸ¯ Definiranje async funkcije
        async function getData() {
            console.log("Fetching data...");

            // â¡ï¸ ÄŒekamo da Promise zavrÅ¡i (kao da smo rekli: "stani ovdje i Äekaj")
            try {
                const response = await fetchData;
                console.log(response); // Ispis: "Data fetched successfully!"
            } catch (error) {
                console.error(error); // U sluÄaju greÅ¡ke
            }
        }

        getData(); // Poziv funkcije



        async function fetchUser() {
        console.log("Fetching user...");

        try {
            const response = await fetch("https://jsonplaceholder.typicode.com/users/1");
            const userData = await response.json(); // Parsiramo JSON
            console.log(userData);
        } catch (error) {
            console.error("Error fetching user:", error);
        }
    }

    fetchUser();

   
    </script>
    
</body>
</html>